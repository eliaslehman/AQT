import gdsfactory as gf
import numpy as np
from gdsfactory import Component, get_layer
from gdsfactory.typings import LayerSpec


def remove_layers(
    cmp: Component,
    layers: list[LayerSpec],
    include_labels: bool = True,
    invert_selection: bool = False,
) -> Component:
    """Recursively removes all polygons/paths in the specified layers.

    This function differs from the gdsfactory `remove_layers` method in that it does not
    flatten the cell when recursively removing geometries.

    Args:
        cmp: The component to remove geometries from.
        layers: A list of layers to remove.
        include_labels: Whether or not to also remove labels.
        invert_selection: If `True`, the specified layers will be kept and all other
            layers will be removed instead.

    Returns:
        The component.
    """
    layers = [get_layer(layer) for layer in layers]

    should_remove = not invert_selection

    def _remove(cell, layers, visited=set()):
        if cell in visited:
            return cell

        cell.filter(
            spec=layers,
            remove=should_remove,
            labels=include_labels,
            polygons=True,
            paths=True,
        )

        visited.add(cell)

        for ref in cell.references:
            _remove(ref.cell, layers, visited=visited)

        return cell

    _remove(cmp._cell, layers)
    return cmp


def meander(N, *, segment=None, length=None, straight=0, radius=30):
    if length:
        n_segments = length - np.pi * (N + 1) * radius + 2 * radius
        segment = n_segments / N

    p = gf.path.straight(straight)
    p += gf.path.arc(radius, 90)
    p += gf.path.straight(segment / 2 - radius)

    for i in range(N - 1):
        sgn = 2 * (i % 2) - 1
        p += gf.path.arc(radius, sgn * 180)
        p += gf.path.straight(segment)

    p += gf.path.arc(radius, -sgn * 180)
    p += gf.path.straight(segment / 2 - radius)
    p += gf.path.arc(radius, sgn * 90)
    p += gf.path.straight(straight)

    return p


def junction_cd_bias(
    jsize,
    lx_slope: float = 1,
    lx_offset: float = 0,
    ly_slope: float = 1,
    ly_offset: float = 0,
):
    match jsize:
        case float():
            jx = jy = jsize
        case (jx, jy):
            ...

    return (jx - lx_offset) / lx_slope, (jy - ly_offset) / ly_slope
