import importlib

import gdsfactory as gf
import gdstk
import numpy as np
from gdsfactory.components import rectangle

from qfab.pdk import CPW, CPW_open
from qfab.pdk import default_pdk as pdk

pdk.activate()


@gf.cell
def border(
    size: tuple[float, float] = (10_000, 10_000), width: float = 50, corner: float = 250
):
    c = gf.Component()

    xsize, ysize = size
    corner = rectangle((corner, corner))

    c1 = c << corner
    c1.move((-xsize / 2, -ysize / 2))

    c2 = c << corner
    c2.mirror((0, 1))
    c2.move((xsize / 2, -ysize / 2))

    c3 = c << corner
    c3.mirror_y()
    c3.move((-xsize / 2, ysize / 2))

    c4 = c << corner
    c4.mirror((0, 1)).mirror_y()
    c4.move((xsize / 2, ysize / 2))

    border = gf.geometry.boolean(
        rectangle((xsize, ysize), centered=True),
        rectangle((xsize - 2 * width, ysize - 2 * width), centered=True),
        "not",
    )

    c << border

    return gf.geometry.boolean(c, None, "or", layer="SC1_E")


@gf.cell
def dipole_qubit(
    pad_x,
    pad_y,
    pad_spacing,
    ground_spacing,
    fillet=0,
):
    c = gf.Component()

    pad = rectangle(size=(pad_x, pad_y), layer="SC1")

    cutout_x = 2 * ground_spacing + pad_x
    cutout_y = 2 * (ground_spacing + pad_y) + pad_spacing
    cutout = rectangle(size=(cutout_x, cutout_y), layer="SC1_E")

    if fillet:
        pad = gf.geometry.fillet(pad, radius=fillet)
        cmp = gf.Component("pad")
        cmp.add_polygon(pad, layer="SC1")
        pad = cmp

        cutout = gf.geometry.fillet(cutout, radius=fillet)
        cmp = gf.Component("cutout")
        cmp.add_polygon(cutout, layer="SC1_E")
        cutout = cmp

    pad1 = c << pad
    pad2 = c << pad

    pad1.move((-pad_x / 2, pad_spacing / 2))
    pad2.move((-pad_x / 2, pad_spacing / 2)).mirror((0, 0))

    cref = c << cutout
    cref.move((-cutout_x / 2, -cutout_y / 2))

    c.add_port(
        "port_N",
        center=(0, cutout_y / 2),
        orientation=90,
        layer="SC1",
        cross_section=pdk.cross_sections["cpw"],
    )

    c.add_port(
        "port_NP",
        center=(0, cutout_y / 2 - ground_spacing),
        orientation=90,
        layer="SC1",
        cross_section=pdk.cross_sections["cpw"],
    )

    c.add_port(
        "port_W",
        center=(-cutout_x / 2, 0),
        orientation=180,
        layer="SC1",
        cross_section=pdk.cross_sections["cpw"],
    )

    return c


@gf.cell
def airbridge(width, span, base, offset=2, fillet=2):
    c = gf.Component()

    b1 = gdstk.rectangle((-base, -base / 2), (0, base / 2)).translate(
        -span / 2 - offset, 0
    )
    b2 = gdstk.rectangle((0, -base / 2), (base, base / 2)).translate(
        span / 2 + offset, 0
    )

    bridge = gdstk.rectangle(
        (-span / 2 - offset, -width / 2), (span / 2 + offset, width / 2)
    )

    if fillet:
        b1.fillet(radius=fillet)
        b2.fillet(radius=fillet)

    bridge = gdstk.boolean([b1, b2], bridge, "or")

    s = base + 2 * offset
    reflow = [
        gdstk.rectangle((-s, -s / 2), (0, s / 2)).translate(-span / 2, 0),
        gdstk.rectangle((0, -s / 2), (s, s / 2)).translate(span / 2, 0),
    ]

    c.add_polygon(bridge, layer="AB1_E")
    c.add_polygon(reflow, layer="AB1_B")

    return c


@gf.cell
def interdigitated_capacitor(N, length, width, fgap, ggap, taper, xsection):
    offsets = (width + fgap) * (np.arange(N) - (N - 1) / 2)
    total_finger_width = N * (width + fgap) - fgap
    xs1 = gf.CrossSection(
        sections=[
            gf.Section(width=width, layer="SC1", offset=ofst) for ofst in offsets[::2]
        ]
    )

    xs2 = gf.CrossSection(
        sections=[
            gf.Section(width=width, layer="SC1", offset=ofst) for ofst in offsets[1::2]
        ]
    )

    xsc = gf.CrossSection(
        sections=[
            gf.Section(
                width=total_finger_width + 2 * ggap,
                layer="SC1_E",
                port_names=("ci", "co"),
            )
        ]
    )

    p1 = gf.path.straight(length - fgap)
    p1.movex(-length / 2)

    p2 = gf.path.straight(length - fgap)
    p2.movex(-length / 2 + fgap)

    pc = gf.path.straight(length)
    pc.movex(-length / 2)

    c = gf.Component()
    finger1 = c << gf.path.extrude(p1, cross_section=xs1)
    finger2 = c << gf.path.extrude(p2, cross_section=xs2)
    cutout = c << gf.path.extrude(pc, cross_section=xsc)

    taper_xs = CPW(width=total_finger_width, gap=ggap)
    p_taper = gf.path.extrude_transition(
        gf.path.straight(taper), gf.path.transition(xsection, taper_xs)
    )

    t1 = c << p_taper
    t2 = c << p_taper
    t1.connect("co", cutout.ports["ci"])
    t2.connect("co", cutout.ports["co"])

    sc = gf.geometry.boolean(c.extract(layers=["SC1"]), [], "or", layer="SC1")
    sc_e = gf.geometry.boolean(c.extract(layers=["SC1_E"]), [], "or", layer="SC1_E")

    c = gf.Component()
    c << sc
    c << sc_e
    c.add_port("i", port=t1.ports["i"])
    c.add_port("ci", port=t1.ports["ci"])
    c.add_port("o", port=t2.ports["i"])
    c.add_port("co", port=t2.ports["ci"])

    return c


@gf.cell
def coupling_pad(length, width, gap, fillet=0):
    c = gf.Component()

    pad = gf.components.rectangle(size=(length, width), layer="SC1", centered=True)
    cutout = gf.components.rectangle(
        size=(length + 2 * gap, width + 2 * gap), layer="SC1_E", centered=True
    )

    c.add_port("i", port=pad.ports["e2"])
    c.add_port("o", port=pad.ports["e4"])

    if fillet:
        pad = gf.geometry.fillet(pad, radius=fillet)
        cmp = gf.Component("pad")
        cmp.add_polygon(pad, layer="SC1")
        pad = cmp

        cutout = gf.geometry.fillet(cutout, radius=fillet)
        cmp = gf.Component("cutout")
        cmp.add_polygon(cutout, layer="SC1_E")
        cutout = cmp

    pad = c << pad
    cutout = c << cutout

    return c


@gf.cell
def bond_pad(length, width, taper, gap, cpw):
    c = gf.Component()

    xs = CPW(width=width, gap=gap)

    pad_path = gf.path.extrude(gf.path.straight(length), cross_section=xs)
    taper_path = gf.path.extrude_transition(
        gf.path.straight(taper), gf.path.transition(xs, cpw)
    )

    xs = CPW_open(width=width, gap=gap)
    open_path = gf.path.extrude(gf.path.straight(gap), cross_section=xs)

    b = c << pad_path
    t = c << taper_path
    o = c << open_path

    t.connect("i", b.ports["o"])
    o.connect("ci", b.ports["ci"])

    sc = gf.geometry.boolean(c.extract(layers=["SC1"]), [], "or", layer="SC1")
    sc_e = gf.geometry.boolean(c.extract(layers=["SC1_E"]), [], "or", layer="SC1_E")

    c = gf.Component()
    c << sc
    c << sc_e
    c.add_port("i", port=b.ports["i"])
    c.add_port("ci", port=o.ports["co"])
    c.add_port("o", port=t.ports["o"])
    c.add_port("co", port=t.ports["co"])

    return c


@gf.cell
def junction_lead(
    base_length,
    base_width,
    taper,
    lead_length,
    lead_width,
    bandaid_width,
    bandaid_length,
    bandaid_overlap: float = 5,
    ports: set[int] = {1},
    wire: float = 0.2,
    undercut: float = 1.2,
    fillet: float = 0.5,
):
    c = gf.Component()

    length = base_length + taper + lead_length
    wire_overlap = lead_width / 2

    pts = np.array(
        [
            (0, base_width / 2),
            (base_length, base_width / 2),
            (base_length + taper, lead_width / 2),
            (length + wire_overlap, lead_width / 2),
        ]
    )

    pts = np.r_[pts, pts[::-1] * (1, -1)]
    fillet_radius = np.zeros(pts.shape[0])
    fillet_radius[3:5] = fillet

    ld_polys = gdstk.Polygon(pts).fillet(fillet_radius, tolerance=fillet / 5e2)

    uc_polys = gdstk.boolean(
        gdstk.offset(ld_polys, undercut, join="round"), ld_polys, "not"
    )

    # wire cutout
    wires = []

    for p in ports:
        orientation = 90 - p * 90

        w = gdstk.RobustPath((wire_overlap, 0), wire).horizontal(
            wire_overlap + undercut
        )

        w.rotate(np.pi * orientation / 180)
        w.translate(length, 0)

        wires += w.to_polygons()

        c.add_port(
            name=f"w{p}",
            center=w.position(1),
            orientation=orientation,
            width=wire,
            layer="JJ1",
            port_type="electrical",
        )

    c.add_port(
        name="lead",
        center=(0, 0),
        orientation=180,
        width=base_width,
        layer="JJ1",
        port_type="electrical",
    )

    ld_polys = gdstk.boolean(ld_polys, wires, "not")
    uc_polys = gdstk.boolean(uc_polys, wires, "not")

    c.add_polygon(wires, layer="JJ1")
    c.add_polygon(ld_polys, layer="SE1")
    c.add_polygon(uc_polys, layer="SE1_UC")

    bandaid = gdstk.rectangle(
        (-bandaid_length, -bandaid_width / 2), (0, bandaid_width / 2)
    )
    bandaid.translate(bandaid_overlap, 0)
    c.add_polygon(bandaid, layer="JJ1_BD")

    return c

@gf.cell
def junction_lead_v2(
    base_length,
    base_width,
    taper,
    lead_length,
    lead_width,
    bandaid_width,
    bandaid_length,
    bandaid_overlap: float = 5,
    ports: set[int] = {1},
    wire: float = 0.2,
    wire_base: float = 0.5,
    undercut: float = 1.2,
    fillet: float = 0.5,
):
    c = gf.Component()

    length = base_length + taper + lead_length
    wire_overlap = lead_width / 2

    pts = np.array(
        [
            (0, base_width / 2),
            (base_length, base_width / 2),
            (base_length + taper, lead_width / 2),
            (length + wire_overlap, lead_width / 2),
        ]
    )

    pts = np.r_[pts, pts[::-1] * (1, -1)]
    fillet_radius = np.zeros(pts.shape[0])
    fillet_radius[3:5] = fillet

    ld_polys = gdstk.Polygon(pts).fillet(fillet_radius, tolerance=fillet / 5e2)

    # uc_polys = gdstk.boolean(
    #     gdstk.offset(ld_polys, undercut, join="round"), ld_polys, "not"
    # )

    # wire cutout
    wires = []

    for p in ports:
        orientation = 90 - p * 90

        w = gdstk.RobustPath((wire_base / 2 - wire_overlap, 0), wire_base).horizontal(
            wire_overlap + undercut - (wire_base - wire) / 2
        ).horizontal(
            wire_overlap + undercut, width=wire
        )

        w.rotate(np.pi * orientation / 180)
        w.translate(length, 0)

        wires += w.to_polygons()

        c.add_port(
            name=f"w{p}",
            center=w.position(2),
            orientation=orientation,
            width=wire,
            layer="JJ1",
            port_type="electrical",
        )

    c.add_port(
        name="lead",
        center=(0, 0),
        orientation=180,
        width=base_width,
        layer="JJ1",
        port_type="electrical",
    )

    bandaid = gdstk.rectangle(
        (-bandaid_length / 2, -bandaid_width / 2), (bandaid_length / 2, bandaid_width / 2)
    )
    bandaid.translate(length, 0)
    c.add_polygon(bandaid, layer="JJ1_BD")

    # ld_polys = gdstk.boolean(ld_polys, [wires], "not")
    # uc_polys = gdstk.boolean(uc_polys, wires, "not")

    c.add_polygon(wires, layer="JJ1")
    c.add_polygon(ld_polys, layer="SC1")
    # c.add_polygon(uc_polys, layer="SE1_UC")

    return c

@gf.cell
def quadrupole_junction(
    jsize,
    lead,
    pad_spacing,
    junction_overlap: float = 3,
    junction_taper: float = 0.2,
    pad_overlap: float = 7,
):
    c = gf.Component()

    lead = lead.copy()

    ld_w = c << lead
    ld_n = c << lead
    ld_e = c << lead
    ld_s = c << lead

    spacing = pad_spacing / 2 + pad_overlap

    ld_w.move("lead", (-spacing, 0))
    ld_n.rotate(-90).move("lead", (0, spacing))
    ld_e.rotate(180).move("lead", (spacing, 0))
    ld_s.rotate(90).move("lead", (0, -spacing))

    jx, jy = jsize

    jh = gdstk.RobustPath(ld_w.ports["w1"].center, width=ld_w.ports["w1"].width)
    jh.horizontal(-junction_overlap / 2 - junction_taper)
    jh.horizontal(-junction_overlap / 2, width=jy)
    jh.horizontal(junction_overlap / 2)
    jh.horizontal(junction_overlap / 2 + junction_taper, width=ld_e.ports["w1"].width)
    jh.horizontal(ld_e.ports["w1"].center[0])

    jv = gdstk.RobustPath(ld_s.ports["w1"].center, width=ld_s.ports["w1"].width)
    jv.vertical(-junction_overlap / 2 - junction_taper)
    jv.vertical(-junction_overlap / 2, width=jx)
    jv.vertical(junction_overlap / 2)
    jv.vertical(junction_overlap / 2 + junction_taper, width=ld_n.ports["w1"].width)
    jv.vertical(ld_n.ports["w1"].center[1])

    c.add_polygon(gdstk.boolean(jh, jv, "or"), layer="JJ1")

    return c


@gf.cell
def manhattan_junction(
    jsize,
    leads: tuple[gf.Component, gf.Component],
    lead_spacing,
    pad_spacing,
    junction_overlap: float = 3,
    junction_taper: float = 0.2,
    pad_overlap: float = 7,
    contact_width: float = 0.04,
    contact_length: float = 0.1,
    undercut_width: float = 0.5,
    undercut_length: float = 1.875,
):
    c = gf.Component()

    ld_l = c << leads[0]
    ld_r = c << leads[1]

    spacing = pad_spacing / 2 + pad_overlap

    ld_l.move("lead", (-spacing, lead_spacing / 2))
    ld_r.rotate(180).move("lead", (spacing, -lead_spacing / 2))

    jx, jy = jsize

    xpos, _ = ld_l.ports["w2"].center
    _, ypos = ld_r.ports["w1"].center

    jh = gdstk.RobustPath(ld_r.ports["w1"].center, width=ld_r.ports["w1"].width)
    jh.horizontal(xpos + junction_overlap / 2 + junction_taper)
    jh.horizontal(xpos + junction_overlap / 2, width=jy)
    jh.horizontal(xpos - junction_overlap / 2)

    jv = gdstk.RobustPath(ld_l.ports["w2"].center, width=ld_l.ports["w2"].width)
    jv.vertical(ypos + junction_overlap / 2 + junction_taper)
    jv.vertical(ypos + junction_overlap / 2, width=jx)
    jv.vertical(ypos - junction_overlap / 2)

    (contact,) = gdstk.boolean(
        gdstk.rectangle((0, -contact_width / 2), (contact_length, contact_width / 2)),
        gdstk.rectangle(
            (contact_length, -contact_width), (2 * contact_length, contact_width)
        ),
        "or",
    )

    undercut = gdstk.rectangle(
        (0, -undercut_width / 2), (undercut_length, undercut_width / 2)
    )
    (undercut,) = gdstk.boolean(undercut, contact, "not")

    c.add_polygon(
        [
            undercut.copy().rotate(np.pi).translate(*jh.position(jh.size)),
            undercut.copy().rotate(-np.pi / 2).translate(*jv.position(jv.size)),
        ],
        layer="JJ1_UC",
    )

    jh = gdstk.boolean(
        jh, contact.copy().rotate(np.pi).translate(*jh.position(jh.size)), "or"
    )
    jv = gdstk.boolean(
        jv,
        contact.copy().rotate(-np.pi / 2).translate(*jv.position(jv.size)),
        "or",
    )
    c.add_polygon(gdstk.boolean(jh, jv, "or"), layer="JJ1")

    return c


@gf.cell
def branding(
    sample_name, fab="Quantum Nanoelectronics Laboratory", font="Roboto Mono", size=100
):
    resources = importlib.resources.files("qfab")
    cal = gf.read.import_gds(resources / "logos.gds", cellname="CAL").remap_layers(
        layermap={(0, 0): (2, 0)}
    )
    aqt = gf.read.import_gds(resources / "logos.gds", cellname="AQT").remap_layers(
        layermap={(0, 0): (2, 0)}
    )

    c = gf.Component()

    name_cmp = gf.components.text_freetype(
        sample_name, size=size, layer="SC1_E", font=font
    )
    name_ref = c << name_cmp

    (x1, y1), (x2, y2) = name_ref.bbox

    fab_cmp = gf.components.text_freetype(fab, size=size / 2, layer="SC1_E", font=font)
    fab_ref = c << fab_cmp
    fab_ref.move((0, -50))

    cal_ref = c << cal
    cal_ref.move((100, -200))

    aqt_ref = c << aqt
    aqt_ref.move((350, -200))

    p1, p2 = c.bbox

    offset = 30
    dx, dy = (p2 - p1) + 2 * offset

    ref = c << gf.components.rectangle((dx, dy), layer="KEEPOUT")
    ref.move(p1 - (offset, offset))

    return c


@gf.cell
def id_box(width=500, height=200):
    box = gf.components.rectangle((width, height), layer="SC1_E")

    c = gf.Component()
    boxref = c << box
    boxref.translate(0, -height)
    return c


@gf.cell
def probe_alignment(letter="Q", size=200, font="Roboto Mono"):
    c = gf.Component()

    align = gf.components.text_freetype(
        letter.upper(), size=size, layer="SC1_E", font=font
    )

    p1, p2 = align.bbox

    center = 0.5 * (p1 + p2)
    ref = c << align

    ref.move(center, (0, 0))

    offset = 30
    p1, p2 = ref.bbox
    dx, dy = (p2 - p1) + 2 * offset

    ref = c << gf.components.rectangle((dx, dy), layer="KEEPOUT")
    ref.move(p1 - (offset, offset))

    return c
